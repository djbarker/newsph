#ifndef SIMULATION_HPP_
#define SIMULATION_HPP_

#include <vector>
#include <string>
#include <sstream>
#include <mpi.h>
#include <spud>
#include "LinkedCellGrid.hpp"
#include "Parameters.h"
#include "Fluid.h"
#include "Region.hpp"
#include "../utils/utils.hpp"

namespace sim
{

template<size_t Dim>
class Simulation
{
public:
	Simulation();
	virtual ~Simulation(){};

	void loadConfigXML(std::string fname);
	void loadWall(std::string fname);

private:
	size_t comm_size;
	size_t comm_rank;

	nvect<Dim,size_t> domains; // how many domains in each dimension
	Region<Dim>		  gdomain; // global domain extent
	Region<Dim>		  ldomain; // local domain extent

	Parameters<Dim> params;
	std::string		root;

	std::vector<Fluid> fluids;
	MultiList<Particle<Dim,2,2>,2,0> fluid_particles;
	LinkedCellGrid<Dim,Particle<Dim,2,2>> cells;

};

template<size_t Dim>
Simulation<Dim>::Simulation()
{
	using namespace std;

	// init MPI variables
	int tmp;
	MPI_Comm_size(MPI_COMM_WORLD,&tmp);
	comm_size = tmp;
	MPI_Comm_rank(MPI_COMM_WORLD,&tmp);
	comm_rank = tmp;

	// domain arrangements
	domains = calc_num_domains<Dim>(comm_size);
	if(!comm_rank) cout << "Domain decomposition: " << domains << endl;
}

template<size_t Dim>
void Simulation<Dim>::loadConfigXML(std::string fname)
{
	using namespace std;
	using namespace Spud;

	if(SPUD_NO_ERROR!=load_options(fname))
	{
		throw("Error loading XML options file!");
	}

	string tmps;
	vector<double> tmpvd;
	double tmpd;

	// check dimensions match
	int dim_opts;
	get_option("/geometry/dimension",dim_opts);

	if(dim_opts!=Dim)
	{
		if(!comm_rank) cerr << "Code not compiled for " << dim_opts << " dimensions." << endl
							<< "Please recompile with Dim=" << dim_opts << "." << endl;

		throw runtime_error("Incorrect dimensions!");
	}

	// get simulation domain
	vector<double> period;
	get_option("/geometry/period",period);
	gdomain.upper = quantity<position,dvect<Dim>>(vector_to_nvect<Dim>(period));

	get_option("/file_io/root",root,"out");

	// load walls
	if(have_option("/file_io/walls"))
	{
		get_option("/file_io/walls",tmps);
		loadWall(tmps);
	}

	// load fluids
	for(int i=0;i<option_count("/physics/fluid");++i)
	{
		stringstream sstr;
		sstr << "/physics/fluid[" << i << "]";
		string path = sstr.str();

		get_option(path+"/name",tmps);
		if(!comm_rank) cout << tmps << endl;

		Fluid tmpf;
		tmpf.gravity = have_option(path+"/gravity");
		get_option(path+"/density",tmpd);
		tmpf.density = quantity<density>(tmpd);

		if(have_option(path+"viscosity/dynamic"))
		{
			get_option(path+"viscosity/dyanmic",tmpd);
			tmpf.viscosity = quantity<viscosity>(tmpd);
		}
		else
		{
			get_option(path+"viscosity/kinematic",tmpd);
			tmpf.viscosity = quantity<IntDim<0,2,-1>>(tmpd)*tmpf.density; // convert to dynamic viscosity
		}
	}

	if(have_option("/physics/gravity"))
	{
		get_option("/physics/gravity",tmpvd);
		params.gravity = quantity<acceleration,dvect<Dim>>(vector_to_nvect<Dim>(tmpvd));
	}

	get_option("/physics/atmospheric_pressure",tmpd,0.0);
	params.bkg_pressure = quantity<pressure>(tmpd);

	// SPH options
	double c0;
	get_option("/sph/c0",c0);

	int ref;
	get_option("sph/reference_fluid",ref,0);

	if(ref<0)
	{
		if(!comm_rank) cerr << "Reference fluid must be zero or above!";
		throw runtime_error("Invalid reference fluid!");
	}

	// set matching speeds of sound
	for(auto& fluid : fluids)
	{
		fluid.speed_of_sound = quantity<velocity>(c0)*sqrt(fluids[ref].density/fluid.density);
	}

	double hfac;
	get_option("/sph/h_factor",hfac);
	if(have_option("/sph/resolution/dx"))
	{
		get_option("/sph/resolution/dx",tmpd);
		params.dx = quantity<length>(tmpd);
		params.h = params.dx*quantity<number>(hfac);
	}
	else
	{
		get_option("/sph/resolution/h",tmpd);
		params.h = quantity<length>(tmpd);
		params.dx = params.h/quantity<number>(hfac);
	}


}

template<size_t Dim>
void Simulation<Dim>::loadWall(std::string fname)
{

}

} /* namespace sim */


#endif /* SIMULATION_HPP_ */
